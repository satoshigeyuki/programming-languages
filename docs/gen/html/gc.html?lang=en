<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<script src="js/lang.js"></script>

<title>プログラミング言語: 保守的GCを使ってみる
  / Programming Languages:
  Playing with conservative GC</title>

<style>
body {counter-reset: h2}
  h2 {counter-reset: h3}
  h3 {counter-reset: h4}
  h4 {counter-reset: h5}
  h5 {counter-reset: h6}

  h2:before {counter-increment: h2; content: counter(h2) ". "}
  h3:before {counter-increment: h3; content: counter(h2) "." counter(h3) ". "}
  h4:before {counter-increment: h4; content: counter(h2) "." counter(h3) "." counter(h4) ". "}
  h5:before {counter-increment: h5; content: counter(h2) "." counter(h3) "." counter(h4) "." counter(h5) ". "}
  h6:before {counter-increment: h6; content: counter(h2) "." counter(h3) "." counter(h4) "." counter(h5) "." counter(h6) ". "}

  h2.nocount:before, h3.nocount:before, h4.nocount:before, h5.nocount:before, h6.nocount:before { content: ""; counter-increment: none } 

h1 {
  font-size   : 14pt;
  font-family : serif;
  margin      : 10pt;
  padding     : 3pt 20pt;
  border-style     : solid;
  border-width     : 1pt 1pt 0pt 15pt ;
   
  border-color     : #99A1AA;
  background-color : #CCCCDD;
}

h2 {
  font-size   : 14pt;
  font-family : serif;
  margin      : 10pt;
  padding     : 3pt 20pt;
  border-style     : solid;
  border-width     : 1pt 1pt 0pt 15pt ;
   
  border-color     : #99A1AA;
  background-color : #DDDDEE;
}

h3 {
  font-size   : 12pt;
  font-family : serif;
  margin      : 14pt;
  padding     : 3pt 20pt;
  border-style     : solid;
  border-width     : 1pt 1pt 0pt 15pt;
  border-color     : #99A1AA;
  background-color : #EEEEFF;
}

div {
  font-size   : 12pt;
  font-family : serif;
  margin      : 10pt;
  padding     : 3pt 20pt;
  border-color     : #99A1AA;
}

p {
  font-size   : 12pt;
  font-family : serif;
  border-color     : #99A1AA;
}

pre {
  background-color:#efe;
}

</style>
</head>

<body onload="main()">

<body>

<h1 class="ja">プログラミング言語: 保守的GCを使ってみる<br />田浦健次朗</h1>
<h1 class="en">Programming Languages: Playing with conservative GC<br />Kenjiro Taura</h1>
<div>
<font size=-1>(the page is encoded in UTF-8)</font>
<ul>
  <li><a href=../../ >top page</a> </li>
  <li><a href="?lang=ja"><img src=img/japan_flag.png border=1 height=16 alt=Japanese /></a> / <a href="?lang=en"><img src=img/english_flag.png border=1 height=16 alt=English /></a> </li>
</ul>

</div>

<div>
  <p class="ja"><font color=red>お知らせ (とおわび)</font></p>
  <p class="en"><font color=red>Announcement (and an apology)</font></p>
  <p class="ja">最初の数問と, 以下の
    テンプレート 04-gc-template.ipynb を 7/2 1:00 ごろに
    <font color=red>変更しています.</font>
    すでに手を付けている人にはすいませんが,
    より問題の意図がわかるように例題を変更しているので,
    すみませんがやり直してください(問題の趣旨は変わっていません).
  </p>
  <p class="en">The first few problems and 
    the template 04-gc-template.ipynb <font color=red>have been changed</font>
    around 7/2 1:00AM.
    Sorry for those who have begun working on them, but
    please start over, as new examples are 
    better aligned to the goal of the problems
    (the goal of the problems remain unchanged).
  </p>
</div>
  
<h2 class="ja">実験のやり方</h2>
<h2 class="en">How to do this exercise</h2>
<div>
  <ul>
    <li class="ja"><font color=blue>04-gc-template.ipynb</font>を開き，
      それを<font color=blue>04-gc</font>にrenameすること
    </li>
    <li class="en">Open <font color=blue>04-gc-template.ipynb</font> and 
      rename it to <font color=blue>04-gc.ipynb</font>
    </li>
    
    <li class="ja">本演習のプログラムはCで書きますが,
      PythonやOCamlと同じようにブラウザの中で書くだけで実行できます(!)</li>
    <li class="en">In this exercise you write programs in C.
      You can put C programs in the browser just as you did
      for Python and OCaml!</li>
    
    <li class="ja">Jupyterに直接Cプログラムを書いてもよいですが,
      自分のPCにBoehm GCが簡単にインストールできるなら(やり方は下記),
      自分のPCでコンパイル&amp; 実行する方がよいかも
      (特にメモリをたくさん使うプログラムなど).</li>
    <li class="en">You can directly write your C program into
      the Jupyter, but if you can easily install Boehm GC into your PC
      (see below for instruction), it might be better to compile and run
      the experiments in your PC
      (esp. for programs that consume lots of memory).</li>
    
    <li class="ja">どちらにせよ,
      提出する際はJupyterに入力, 実行してください.
      また進捗を見るために一問できたらすぐにJupyterに入力してください.</li>
    <li class="en">Regardless, please input to and run in the Jupyter
      environment to submit your work.
      Please submit as soon as you solve a problem, so I can see
      your progress.</li>
    
    <li class="ja">セルには以下の形式でソースコードとコンパイル,
      実行するためのコマンドを書いてください
<pre class="ja">
%% ソースコードを保存するファイル名
%  実行したいコマンド
%  実行したいコマンド
%  ...

ソースコード
</pre>
    </li>
    <li class="en">Put into each cell the source code and commands to compile and execute it, in the following format
<pre class="en">
%% name of the file to save source code into
%  command to execute
%  command to execute
%  ...

source code
</pre>
    </li>

    <li class="ja">実行例:
      <p>
        <img src=img/c-kernel-example.png />
      </p>
    </li>
    <li class="en">Example:
      <p>
        <img src=img/c-kernel-example.png />
      </p>
    </li>

<li class="ja">セルの中身は以下のように解釈されます．
<ul>
  <li class="ja"><tt>%%</tt> で始まる行はソースコードが保存される(作られる)ファイル名</li>
  <li class="ja"><tt>%</tt> で始まる行はファイルを作った後に実行されるコマンド(いくつでも良い)</li>
  <li class="ja">それ以外の行はファイルに保存される中身</li>
</ul>
</li>

<li class="en">The cell is processed as follows
<ul>
  <li class="en">the line beginning with <tt>%%</tt> specifies the name of the (created) file the source code will be saved into</li>
  <li class="en">lines beginning with <tt>%</tt> specify commands to execute after the file is saved (put as many as you like)</li>
  <li class="en">other lines are put into the file</li>
</ul>
</li>

    <li class="ja">コマンドは，手元のPCではなく，クラウド上で実行されます．もちろんファイルが作られるのもクラウド上です．
<tt>%</tt> で始まる行を使って，コンパイルや，出来たプログラムを実行するコマンドなども，
自分で書いて下さい．プログラムを貼り付けただけで，
勝手にコンパイル，実行されるわけではありません．
エラーや実行結果などもブラウザに表示されるので通常のLinux環境と思ってよいですが，
田浦が急造した環境なので，動作に不審な点があったら遠慮無く質問して下さい．
    </li>

    <li class="en">Commands will be executed on the cloud, not on your PC.  The file is created on the cloud, of course.
      Write lines beginning with <tt>%</tt> to specify commands to compile the source code and execute the produced executable.
      Your program won't be automatically compiled or executed.
      Errors and output from your program are also displayed in the browser, so you may consider it to be an ordinary Linux environment.
      The environment was, however, quickly made by Taura,
      so never hesitate to ask me if you notice anything strange.
    </li>

    <li class="ja">可視化をする問題については，まずはgnuplotを使って，
      結果のsvgファイルを出力して下さい．</li>
    <li class="en">For problems asking you to visualize something,
      use gnuplot to output the visualization into an svg file.</li>
    
    <li class="ja">自分のPCで実行した場合, そのSVGファイルを，
      Jupyterのファイルアップロード機能を使ってアップロードして下さい．
      画面左上のjupyterアイコン (<img src=img/jupyter_icon.png height=20 />)
      をクリックすると，アップロードボタン (<img src=img/upload_button.png height=20 />)
      が出てきます．それを押してアップロードします．</li>
    <li class="en">When you run experiments in your PC,
      upload the generated SVG file with the upload
      function of Jupyter; click the jupyter icon
      (<img src=img/jupyter_icon.png height=20 />)
      on the upper left corner of the browser window
      and show the upload button
      (<img src=img/upload_button.png height=20 />).
      Press it to upload.</li>
    
    <li class="ja">アップロードしたらそのファイルを，
      Jupyterのファイル一覧から選んで表示すると，
      画像として見えるはずです．</li>
    <li class="en">Once you upload it, you can display
      it by selecting it from the file browser of
      Jupyter.</li>

    <li class="ja">6までを必須課題とします．
      残りは余力に応じてやって下さい．</li>
    <li class="en">Problems up to 6 is mandatory.
      Work on further problems as far as you can.</li>

    <li class="ja">提出はその状態のファイルを残した上で，
      田浦宛にそのURLを送って，提出とする．最低限以下の情報を含める．
<pre class="ja">
To: tau@eidos.ic.i.u-tokyo.ac.jp
Subject: プログラミング言語 課題4

学生証番号: ○○○○○○
氏名:       ○○

です．プログラミング言語の課題を以下に提出します．

      http://[授業で指示したURL]:[自分のポート番号]/notebooks/04-gc.ipynb
</pre>
    </li>

  <li class="en">Submit your work by leaving the file that satisfied the above requirement and sending me the URL of it.
    Include the following information at minimum.
<pre>
To: tau@eidos.ic.i.u-tokyo.ac.jp
Subject: Programming Languages Assignment 4

Student ID: ○○○○○○
Name:       ○○

I submit the assignment as follows.

      http://[URL told in the class]:[your port number]/notebooks/04-gc.ipynb
</pre>
  </li>
    
    <li class="ja">締め切り: 2018/7/?? (土) 23:59</li>
    <li class="en">Due: 2018/7/?? (Sat) 23:59</li>
</ul>

</div>


<h2 class="ja">リファレンス</h2>
<h2 class="en">Reference</h2>
<div>
<ul>
<li>
  <a href=http://hboehm.info/gc/ target=_blank>Boehm GC HP</a>
</li>
</ul>
</div>

<h2 class="ja">インストール</h2>
<h2 class="en">Install</h2>
<div>
  <p class="ja">
    自分のPCで実行する場合, 以下のどちらかでインストール.
  </p>
  <p class="en">
    If you run your experiments on your own PC,
    install it by either of the following.
  </p>
<ul>
  <li class="ja">Ubuntuのパッケージをインストール:
<pre>
$ sudo apt-get install libgc-dev
</pre>
</li>
<li class="en">install Ubuntu package:
<pre>
$ sudo apt-get install libgc-dev
</pre>
</li>

<li class="ja">ソースからコンパイル: 
<ol>
<li><a href=http://hboehm.info/gc/ target=_blank>本家HP</a>からダウンロードする.
以下では，<a href=http://hboehm.info/gc/gc_source/gc-7.4.0.tar.gz>gc-7.4.0.tar.gz</a>
  を入手したとする
</li>
<li>
インストールしたいディレクトリを決め，以下の手順でコンパイル．
以下の PREFIX はインストールしたいディレクトリで置き換える．
<pre>
$ tar xf gc-7.4.0.tar.gz
$ cd gc-7.4.0
$ ./configure --prefix=<font color=red>PREFIX</font>
$ make
$ make install
</pre>
</li>

<li>configureの際に，libatomic がないみたいなことを言われたら，Ubuntuであれば，
<pre>
$ sudo apt-get install libatomic-ops-dev
</pre>
そうでなければ，同サイトからダウンロードする．
</li>
</ol>
</li>

<li class="en">compile from source: 
<ol>
  <li>download the source from <a href=http://hboehm.info/gc/ target=_blank>the  home page</a>.  Say you got
    <a href=http://hboehm.info/gc/gc_source/gc-7.4.0.tar.gz>gc-7.4.0.tar.gz</a>
  </li>
  <li>
    Decide the install directory (directory you install it into)
    and compile the source as follows.
    Replace <tt>PREFIX</tt> below with the installation directory.
<pre>
$ tar xf gc-7.4.0.tar.gz
$ cd gc-7.4.0
$ ./configure --prefix=<font color=red>PREFIX</font>
$ make
$ make install
</pre>
  </li>
  <li>if the <tt>configure</tt> above
    complains saying <tt>libatomic</tt> is missing or something,
    do the following if you are on Ubuntu.
<pre>
$ sudo apt-get install libatomic-ops-dev
</pre>
On other platforms, download it from the same site.
</li>
</ol>
</li>
</ul>
</div>

<h2 class="ja">使い方</h2>
<h2 class="en">How to use</h2>
<div>
<ul>
  <li class="ja"> ヘッダファイル gc/gc.h をインクルード</li>
  <li class="en"> include the header file <tt>gc/gc.h</tt></li>

  <li class="ja"> 最初にGC_INIT()を呼ぶ(プラットフォームによって必須の場合とそうでない場合があるようです．Linuxでは不要，Mac OS Xでは必須のよう)</li>
  <li class="en"> call <tt>GC_INIT()</tt> at the beginning (depending on the platform, you may or may not need it.  It seems you don't need it on Linux and you do need it on Mac OS X)</li>

  <li class="ja"> malloc, calloc するところで代わりに GC_MALLOC を呼ぶ</li>
  <li class="en"> call <tt>GC_MALLOC</tt> instead of <tt>malloc</tt> or <tt>calloc</tt></li>
  
  <li class="ja"> free は呼ばなくてよい</li>
  <li class="en"> you don't have to call <tt>free</tt></li>
  
  <li class="ja"> コマンドラインに -lgc を与えてリンク</li>
  <li class="en"> give <tt>-lgc</tt> on the command line to link</li>
</ul>

<p class="ja">
  例(ex.c):
</p>
<p class="ja">
  Example (ex.c):
</p>

<pre>
#include &lt;stdio.h&gt;
<font color=blue>#include &lt;gc/gc.h&gt;</font>

int main() {
  <font color=blue>GC_INIT();</font>
  void * p = <font color=blue>GC_MALLOC(128);</font>
  printf("%p\n", p);
  return 0;
}
</pre>

<pre>
$ <font color=blue><u>gcc ex.c -lgc</u></font>
</pre>
<p class="ja">
  自分でソースからインストールした場合は，
</p>
<p class="en">
  If you built the library yourself from source,
</p>
<pre>
$ <u>gcc -I<font color=red>PREFIX</font>/include -L<font color=red>PREFIX</font>/lib -Wl,-R<font color=red>PREFIX</font>/lib  ex.c -lgc</u>
</pre>

<p class="ja">
<font color=red>PREFIX</font>の部分はconfigureを実行したときに,
--prefix で指定したインストールパス. インストールが成功していれば,
<tt><font color=red>PREFIX</font>/include/gc/gc.h</tt>や
<tt><font color=red>PREFIX</font>/lib/libgc.so</tt>
というファイルが存在しているはず.
</p>
<p class="en">
  Replace the <font color=red>PREFIX</font> with
  the installation directory you specified with <tt>--prefix</tt>
  when you <tt>configure</tt>.  If your installation went successfully,
  there should be files
<tt><font color=red>PREFIX</font>/include/gc/gc.h</tt> and
<tt><font color=red>PREFIX</font>/lib/libgc.so</tt>
</p>

</div>


<h2 class="ja">GCの効果を体験してみる</h2>
<h2 class="en">Try GC and see it's working</h2>

<div>
  <p class="ja">
    まず以下のプログラムは，引数sz, l, mを受け取り，
    まずl要素のポインタを保持できる配列aを作り,
    その後, 大きさszバイトのデータ(以下, オブジェクトと呼ぶ)
    をm回作り, そのうち
    (最近の)l個を配列aの要素として保持する.
    終了後に性能の指標として，
    オブジェクトを一回割り当てるのにかかった平均時間を表示する．
  </p>
  <p class="en">
    The following program receives three parameters
    <tt>sz, l</tt> and <tt>m</tt> and
    creates an array that can hold <tt>l</tt> pointers;
    then it creates data (we hereafter call them objects)
    of sz bytes m times and keeps the most recent l of them
    in the array;
    it displays the average time per object allocation
    as the measure of performance.
  </p>


<pre>
$ <font color=blue><u>gcc -O3 array.c</u></font>
$ <font color=blue><u>./a.out 1000 12345 123456</u></font>
object size = 1000 bytes
array length = 12345
iterations = 123456
minimum = 8 * 12345 + 1000 * 12345 = 12443760
total alloc = 8 * 12345 + 1000 x 123456 = 123554760
0.045549 sec for 123456 allocs (368.948580 nsec per alloc)
</pre>

<p class="ja">
  <a href=download/array.c>ダウンロード</a>
</p>
<p class="en">
  <a href=download/array.c>download</a>
</p>
<pre>
#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/time.h&gt;

double cur_time() {
  struct timeval tp[1];
  gettimeofday(tp, 0);
  return tp-&gt;tv_sec + tp-&gt;tv_usec * 1.0e-6;
}

void * alloc(long sz) {
  void * p = calloc(sz, 1);
  assert(p);
  return p;
}

int main(int argc, char ** argv) {
  long sz = (argc &gt; 1 ? atol(argv[1]) : 1000); /* cell size */
  long l = (argc &gt; 2 ? atol(argv[2]) : 12345); /* length of the array */
  long m = (argc &gt; 3 ? atol(argv[3]) : 123456); /* the number of times a list is made */
  
  printf("object size = %ld bytes\n", sz);
  printf("array length = %ld\n", l);
  printf("iterations = %ld\n", m);
  printf("minimum = %ld * %ld + %ld * %ld = %ld\n",
         sizeof(void*), l, sz, l, sizeof(void *) * l + sz * l);
  printf("total alloc = %ld * %ld + %ld x %ld = %ld\n",
         sizeof(void*), l, sz, m, sizeof(void *) * l + sz * m);

  double t0 = cur_time();
  long i;
  /* create an array holding pointers to l objects */
  void ** a = (void **)alloc(sizeof(void *) * l);
  /* create an object m times, keeping l of them alive */
  for (i = 0; i &lt; m; i++) {
    a[i % l] = alloc(sz);
  }
  double t1 = cur_time();
  double dt = t1 - t0;
  printf("%f sec for %ld allocs (%f nsec per alloc)\n", 
	 dt, m, dt * 1.0e9 / m);
  return 0;
}
</pre>

  <p class="ja">
    このプログラムはcallocを用いてセルを割り当てているが，
    <font color=red>どこでもfreeはしていないため，割り当てただけのメモリを実際に使ってしまう．</font>
    /usr/bin/time コマンドを用いると，
    プログラムが消費したメモリ量を見ることができる．
    単位はLinuxではKB.  他の環境では違うかもしれないのでマニュアル参照.
  </p>
  <p class="en">
    As this program allocates cells using <tt>calloc</tt>
    yet <font color=red>never calls <tt>free</tt>,
      it therefore consumes the amount of memory as much as it allocates.
    </font>
    You can see the amount of memory it consumed by
    <tt>/usr/bin/time</tt> command.  The unit is KB on Linux.
    Other platforms may use a different unit (consult the manual).
</p>

  <p>
<pre>
$ <font color=blue><u>/usr/bin/time ./a.out 1000 12345 123456</u></font>
object size = 1000 bytes
array length = 12345
iterations = 123456
minimum = 8 * 12345 + 1000 * 12345 = 12443760
total alloc = 8 * 12345 + 1000 x 123456 = 123554760
0.051090 sec for 123456 allocs (413.831665 nsec per alloc)
0.00user 0.04system 0:00.05elapsed 100%CPU (0avgtext+0avgdata <font color=red>123328maxresident</font>)k
0inputs+0outputs (0major+30471minor)pagefaults 0swaps
</pre>
</p>

<p class="ja">
<font color=red>123328maxresident</font>の部分が，
このプロセスが，実行中最大で123328 KB (= 123 MB)
の物理メモリを占めていたことを表している．
  </p>
  <p class="en">
    <font color=red>123328maxresident</font> indicates the process
    occupied up to 123328 KB (= 123 MB) of memory during the execution.
  </p>

  <p>
    <font color=blue>Q:</font>
  </p>
  
  <p class="ja">
このプログラムがcallocを用いている部分を変更して，GC_MALLOCを用い，
メモリ消費量が少なくなっていることを，上と同じようにして確かめよ．
  </p>
  <p class="en">
    Change the part of the program that calls <tt>calloc</tt>
    so that they call <tt>GC_MALLOC</tt> instead and observe
    the memory usage in fact reduces.
  </p>
</div>


<h2 class="ja">メモリ使用量とGC性能のトレードオフ</h2>
<h2 class="en">The trade off between memory usage and GC performance</h2>
<div>
  <p class="ja">Boehm GCを用いるプログラムでは</p>
  <p class="en">In a program using Boehm GC,</p>
<pre>
GC_set_free_space_divisor(d);
</pre>
  <p class="ja">
(dは1以上の小さな整数)という関数を呼び出すと，
プログラムがどのくらいのメモリを使うかを調整できる．
メモリをたくさん使うと，
GCのオーバーヘッドは相対的に少なくなる．
大雑把に言って，GC_set_free_space_divisor(d)は，
メモリサイズを，
  </p>
<blockquote class="ja">
GC後に生き残ったオブジェクトの合計量 x (1 + 2/d)
</blockquote>
  <p class="ja">
    くらいにする．より正確には，gc.hの説明を参照．
    これはdからメモリ使用量を見積もる
    有用な式である. 一方で,
    「GC後に生き残ったオブジェクトの合計量」
    はGCが起きるタイミングによっても変わるし,
    保守的GCの性質から, 自分が予期していないオブジェクトが
    生き残ることもあるため,
    正確な予測は難しいことも頭に入れておく.
  </p>
  <p class="en">
    (where <tt>d</tt> is an integer &gt;= 1),
    will control the memory usage of the program.
    The more memory you use, the smaller the overhead
    of GC becomes.  Roughly speaking, 
    <tt>GC_set_free_space_divisor(d)</tt>
    sets the heap size of the program
    approximately to:
  </p>
<blockquote class="en">
the total size of live objects after a GC x (1 + 2/d)
</blockquote>
  <p class="en">
    Consult <tt>gc.h</tt> for more accurate information.
    This is a useful formula to predict
    the memory usage from <tt>d</tt>.
    Bear in mind though, that 
    an accurate prediction is still difficult,
    because "the total size of live objects after a GC"
    depends on when GC happens
    and also because objects may unexpectedly be
    retained due to the nature of conservative GC.
  </p>

  <ol>
    <li class="ja">
<pre>
GC_get_gc_no();
</pre>
という関数を呼び出すと，
それまでにおこなわれたGCの回数がわかる．
    </li>
    <li class="en">
<pre>
GC_get_gc_no();
</pre>
    tells you the number of times GCs have happened.
    </li>
    <li class="ja">
<pre>
GC_get_heap_size();
</pre>
という関数を呼び出すと，その時点でのGCが管理するメモリ(ヒープ)の
サイズがわかる.
    </li>
    <li class="en">
<pre>
GC_get_heap_size();
</pre>
tells you the current size of the memory managed by GC (heap).
    </li>
  </ol>

<font color=blue>
  Q:
</font>
  <p class="ja">
    プログラムを以下のように変更せよ.
  </p>
  <p class="en">
    Change the program as follows.
  </p>
<ul class="ja">
  <li>
    4番目の引数としてdを受け取り，
    GC_set_free_space_divisor(d)を呼び出す, </li>
  <li>プログラム終了時に, 起きたGCの回数と,
    ヒープサイズを表示する
  </li>
</ul>
<ul class="en">
  <li>it takes
    a value of <tt>d</tt> as the fourth parameter
    and calls <tt>GC_set_free_space_divisor(d);</tt></li>
  <li>and it shows the number of times GCs have happened
    and how large the heap is at the end of the program</li>
</ul>
<p class="ja">
同じsz, l, mの値に対して，
dの値を色々変えて，性能(セル割り当て一回あたりの時間)と，
GC回数，メモリ消費量の関係を見てみよ．
</p>
<p class="en">
    Fix <tt>sz, l</tt> and <tt>m</tt> and
    change <tt>d</tt>, and observe
    the relationship among
    performance (the average time it took to allocate a cell),
    the number of GCs,
    and the memory usage.
</p>
</div>

<!--
<h2 class="ja">たくさんメモリを使わせる</h2>
<h2 class="en">Give it a lot of memory</h2>
<div>
  <p class="ja">
    dを調節するというやり方は，
    メモリ使用量とGC性能のトレードオフを調節する有効なやり方である．
    使用するメモリは，「GC後に生き残ったオブジェクトの合計量」を元にして，
    (小さな)係数をかけているだけなので，使用するメモリ量は，近似的には
    「実際に必要とするメモリ量」の数倍に収まる
  </p>
  <p class="en">
    Adjusting d is an effective method to strike a balance
    between memory usage and GC performance.
    The memory usage is based on "the total size of objects
    alive after GC" and is a (small) constant factor of it.
    It is therefore approximately a small constant factor of
    "the really necessary" amount of memory.
  </p>

  <p class="ja">
しかしここでは実験のため，より大きなメモリを無理やり使わせてみる．
そのために，プログラム開始直後に長大なリストを一個作る．
例えば100万要素からなるリストを作れば，
その時点で100万セル程度のメモリが必然的に使われる．
そのリストを解放し,
その後で短命なオブジェクトをたくさん割当れば，
結果的には余剰メモリがふんだんにある状態で，
メモリ割り当てが行われることになる．
  </p>
  <p class="ja">
    In this experiement, you force the GC to use much more memory.
    To that end, you create a huge list immediately after the program starts.
    For example, if you create a list of a million elements,
    the memory worth a million list cells is certainly consumed.
    If you discard the list and then create so many short-lived
    objects, you effectively allocate memory with an abundant memory.
  </p>
  
    <p class="ja">
プログラムを変更して，5番目の引数nを受け取り，
最初に長さnのリストを作るようにせよ．
sz, l, m, dを一定にして，nを色々変え，
nとともにGC回数や性能がどのように変わるかを見てみよ．
(最初に長さnのリストを作る部分は，経過時間やGC回数には含めないで測定せよ).
    </p>
  <p class="en">
    Modify the program so that it takes a fifth argument, n,
    and creates a list of n elements after it starts.
    Fix sz, l, m and d and set n to various values
    and observe the number of GCs and performance.
    (do not count the part that makes the list of n
    elements in the beginning, either in the elapsed time
    or the GC count).
  </p>
</div>
-->

<h2 class="ja">GCとfreeを比べる</h2>
<h2 class="en">Compare GC and free</h2>
<div>
  <p><font color=blue>
    Q:
  </font></p>
  <p class="ja">
    GCを使う代わりに手動でリストを解放する
    (GC_MALLOCではなくmallocとfreeを使う)ようにプログラムを書き換えて，
    同じ測定(メモリ使用量とメモリ割当て一回のコスト)
    をしてみよ．性能をGCと比べよ?
  </p>
  <p class="en">
    Modify the program so as to manually free the lists
    (use <tt>malloc</tt> and <tt>free</tt> instead of <tt>GC_MALLOC</tt>)
    and perform the same measurement.  Compare the performance to GC.
  </p>
</div>

<h2 class="ja">メモリ管理の挙動を調べてみる</h2>
<h2 class="en">Observe the behavior of memory management</h2>
<div>
  <p class="ja">
    メモリ管理(malloc/free や Boehm GC ライブラリ)
    がアドレスをどのように割り当ててくるかを表示してみよう．
  </p>
  <p class="en">
    Let's display addresses allocated
    by (returned from) memory allocators
    (malloc/free or Boehm GC library).
  </p>
  <p class="ja">
    例として，例によって，
    <a href=download/bstree.c>2分木探索のプログラム</a>をとりあげる．
    これはコンパイルして2つの引数n mを与えて動かすと，
  </p>
  <p class="en">
    As always, we will take
    <a href=download/bstree.c>a binary tree search program</a>
    for example.
    Given two arguments n and m, this program:
  </p>

  <ol>
    <li class="ja">空の木をつくる</li>
    <li class="en">creates an empty tree,</li>
    <li class="ja">
      そこにランダムな要素をn 回挿入(各要素は，0 &lt;= x &lt; 2*n) </li>
    <li class="en">
      inserts random elements
      (each element <i>x</i> satisfies 0 &lt;= <i>x</i> &lt; 2*n)
      <i>n</i> times,</li>
    <li class="ja">
      さらに，「ランダムな要素を挿入; ランダムな要素を削除」を m 回繰り返す(各要素は，0 &lt;= x &lt; 2*n)</li>
    <li class="en">
      repeat
      "insert a random element; delete a random element"
      <i>n</i> times
      (each element <i>x</i> satisfies 0 &lt;= <i>x</i> &lt; 2*n)
    </li>      
    <li class="ja">最後に全ての要素を削除</li>
    <li class="en">and finally delete all elements.</li>
  </ol>
  <p class="ja">
    という動作をする．
    つまり,
    だいたいn要素数を保ったまま，挿入と削除を繰り返す．
  </p>
  <p class="en">
    That is, it repeats "inserting an element and delete an element",
    keeping the number of elements around <i>n</i>.
  </p>
  
  <p class="ja">
    また，GCライブラリを用いても用いなくてもコンパイルできるようになっている．
    用いる場合は， -DUSE_GC=1 というフラグを与え，-lgc でリンクする．
  </p>
  <p class="en">
    It can be compiled both with and without the GC library.
    If you want to compile it with GC,
    give <tt>-DUSE_GC=1</tt> for a compilation flag
    give <tt>-lgc</tt> to link.
  </p>

<p class="ja">
  GCあり:
</p>
<p class="en">
  With GC:
</p>
<pre>
$ gcc -o bstree_gc -DUSE_GC=1 bstree.c -lgc
$ ./bstree_gc 1000 10000
./bstree_gc 1000 10000
780 nodes in the tree
</pre>
<p class="ja">
  GCなし:
</p>
<p class="en">
  without GC:
</p>
<pre>
$ gcc -o bstree_nogc bstree.c
$ ./bstree_nogc 1000 10000
./bstree_nogc 1000 10000
780 nodes in the tree
</pre>
<p>
  <font color=blue>Q:</font>
</p>
  <p class="ja">
    このプログラムの動作を理解し，メモリを割り当てている部分を修正して，
    割り当てられたアドレスを以下の書式で表示するようにせよ．
  </p>
  <p class="en">
    Understand this program and modify
    the part allocating memory, so as to display
    the allocated addresses in the following format.
  </p>
<pre class="ja">
born: 割り当てられたアドレス 要求したバイト数
</pre>
<pre class="en">
born: address-allocated bytes-requested
</pre>
<p class="ja">
  実行例:
</p>
<p class="en">
  Example:
</p>
<pre>
$ ./bstree_gc 1000 10000 | head -20
born: 12808160 24 bytes
born: 12808128 24 bytes
born: 12808096 24 bytes
born: 12808064 24 bytes
born: 12808032 24 bytes
born: 12808000 24 bytes
  ...
</pre>
<p class="ja">
<font color=red>注:</font>
大きなn, mに対して実行すると実行結果が巨大になってしまうので,
Jupyter上ではheadコマンドで出力行数を制限して実行すること.
</p>
<p class="en">
  <font color=red>Remark:</font>
  As the output becomes huge for large n and m,
  limit the number of lines with the <tt>head</tt> command.
</p>
</div>


<h2 class="ja">割り当てられたアドレスの可視化</h2>
<h2 class="en">Visualize allocated addresses</h2>
<div>
  <p>
    <font color=blue>Q:</font>
  </p>
  <p class="ja">
    上のプログラムの出力を読み取って，
    横軸に割り当ての回数(何回目のbornか)，
    縦軸にそのアドレスを表示し，gnuplotで可視化してみよ．注目点は，
  </p>
  <p class="en">
    Read the output of the above program
    and visualize the addresses with gnuplot,
    taking the number of allocations on the horizontal axis
    and the addresses on the virtual axis.
    Pay attention to:
  </p>
<ul>
  <li class="ja">どのくらいの範囲のアドレスが使われているか．
    つまりヒープとしてどのくらいの量を使っているか．
    GCの場合，それがGC_free_space_divisorの設定でどう変わるか?</li>
  <li class="en">How large is the range of the addresses used?
    That is, how much memory is used as the heap?
    With GC, how is it affected by the parameter
    given to <tt>GC_free_space_divisor</tt>?
  </li>
  <li class="ja">返されるアドレスはバラバラか，ある程度規則性があるか? </li>
  <li class="en">
    Are addresses returned random, or somewhat regular?
  </li>
  <li class="ja">授業で説明したGCの挙動と合わせて合点がいくか?</li>
  <li class="en">Overall does it look reasonable
    given the behavior you learned from the lecture?</li>
</ul>

  <p class="ja">
    可視化の方法: 
    例えば上記のデータが addr.dat というファイルに格納されているなら，
    gnuplotで，
  </p>
  <p class="en">
    How to visualize:
    If the data is in a file, say <tt>addr.dat</tt>,
    entering the following command to gnuplot:
</p>
<pre>
$ <u>gnuplot</u>
gnuplot&gt; <u>plot "addr.dat" using 2</u>
</pre>
  <p class="ja">
    とすればアドレスが可視化できる.
  </p>
  <p class="en">
    will do.
  </p>

  <p class="ja">
    できたらグラフをsvgファイルに保存してアップロードせよ．
    グラフをsvgファイルに保存するには，
  </p>
  <p class="en">
    Once you are done, save the visualization into an svg file
    and upload it.
    To save the graph into an svg file, write a file (save.gpl)
    of the following contents
  </p>
<pre>
set terminal svg
set output "addr.svg"
plot "addr.dat" using 2
</pre>
<p class="ja">
  という内容のファイル(save.gpl)を書いてgnuplotで実行する.
</p>
<p class="en">
  and execute it with <tt>gnuplot</tt>.
</p>
<pre>
$ <font color=blue><u>gnuplot save.gpl</u></font>
</pre>
</div>


<h2 class="ja">オブジェクトの寿命を調べる</h2>
<h2 class="en">Examine lifetime of objects</h2>
<div>
  <p class="ja">
このプログラムにおいて， weak generational hypothesis 
(ほとんどのオブジェクトは短命である)は成り立っているだろうか? また，
仮に若い世代にGCを集中させることができたら，mark-cons比はどのくらいに
なるだろうか? それを知るために，このプログラムが作るオブジェクトの寿命
=「作られてから，不要になるまでの期間」を測ってみよう．
ただしここで, 「期間」は，行われたメモリ割当量で測る．
  </p>
  <p class="en">
    Does the
    weak generational hypothesis
    (most objects die young) hold in this program?
    Another important question is what is the mark-cons ratio
    if GC is focused on a young generation.
    To find out, let's measure the
    lifetime of objects
    (= the period of time from they are born until they become dead) 
    created in this program.
    Here, "the period of time" is measured by
    the amount of memory allocated.
  </p>

  <p>
    <font color=blue>Q:</font>
  </p>
  
  <p class="ja">
    このプログラムをさらに修正し，
    あるノードが生まれた時点の表示に加え，
    不要になった時点で以下の書式でそれを表示する
    (注: このプログラムにおいてはGCも参照カウントも
    不要で簡単にわかります．プログラム中にもすでにそのためのコードが入っています)．
  </p>
  <p class="en">
    Modify the program further so that it displays,
    in addition to events in which
    objects are born,
    events in which objects become unnecessary
    (remark: in this program you can easily know
    where they happen; neither GC nor reference counting
    is necessary.
    The program already contains code that signifies them)．
  </p>

<pre class="ja">
dead: 不要になったオブジェクト(木のノード)のアドレス
</pre>
<pre class="en">
dead: <i>the-address-of-now-unnecessary-object</i>
</pre>

  <p class="ja">
    例:
  </p>
  <p class="en">
    Example:
  </p>
  
<pre>
$ ./bstree_gc 100000 1000000
born: 12808160 24 bytes
dead: 12808160
born: 12808128 24 bytes
born: 12808096 24 bytes
dead: 12808096
dead: 12808128
born: 12808064 24 bytes
born: 12808032 24 bytes
born: 12808000 24 bytes
 ...
</pre>
</div>

<a name=visualize_lifetime>
<h2 class="ja">オブジェクトの寿命分布を可視化</h2>
<h2 class="en">Visualize distribution of object lifetimes</h2>
<div>
  <p>
    <font color=blue>Q:</font>
  </p>
  <p class="ja">
上記のプログラムの出力を読み取り，
オブジェクトの寿命の度数分布をgnupotで可視化せよ．
可視化の前に自分でこのプログラムの挙動を想像し，
寿命の分布はどうなっているか(一様か，偏っているか，
偏っているとしたらどのへんに偏っているか，など)
を予想してみよ．
  </p>
  <p class="en">
    Read the output of the above program and visualize
    the distribution of object lifetimes.
    Before seeing the result, imagine the behavior of the program
    and predict what does the lifetime distribution
    look like (e.g., is it uniform or skewed? if it is skewed,
    how?).
  </p>

  <p class="ja">
    オブジェクトの寿命を調べるには，
    あるアドレスが "born: ..." で表示されてから，
    そのアドレスが， "dead: ..." で表示されるまでの
    メモリ割り当てバイト数を調べれば良い．例えば，
  </p>
  <p class="en">
    To know the lifetime of an object,
    all you have to do is to count
    the number of bytes allocated
    after an address appears at a line
    of "born: ..." until it appears
    at a line of "dead: ...".
    For example, if you have a sequence like:
  </p>
<pre>
born: <font color=red>12808128</font> 24 bytes
born: 12808096 <font color=orange>24 bytes</font>
dead: 12808096
dead: <font color=red>12808128</font>
  ...
</pre>
  <p class="ja">
という列があった時に，最初の行で<font color=red>
12808128</font>にわりあてられたオブジェクトの寿命は，
24バイト，ということである(オブジェクトの
寿命は，そのオブジェクトが割り当てれた<font color=red>後</font>，
そのオブジェクトが死ぬまでに行われたメモリ割り当て量で測る．この場合，
  </p>
  <p class="en">
    we can learn that the object allocated
    at address <font color=red>12808128</font>
    had a lifetime of 24 bytes (lifetime of
    an object is measured by the amount
    of memory allocation <font color=red>after</font>
    the object is born and until it is dead.
    In this case, we count the line
  </p>
<pre>
born: 12808096 <font color=orange>24 bytes</font>
</pre>
  <p class="ja">
    と表示された行をカウントして，24バイトとなっている)．
  </p>
  <p class="en">
    and learn it is 24 bytes)．
  </p>
  <p class="ja">
この可視化を行うためには，各時点でどのアドレスが割り当て中か，
などを把握するプログラムが必要である．ログを解析するプログラムを
好きな言語で書いても良いし，bstree.c プログラムそのものを変更してもよい
(練習としては前者をおすすめする．この手のことをするときには，
なるべく元のプログラムに対する変更を単純で，
解析内容と独立にしておいたほうがよい)．
  </p>
  <p class="en">
    In order to perform this visualization, you need to
    have a program that keeps track of which addresses
    are in use at each point in time.  You can do this
    either by writing
    a program that analyzes the log in a language
    you choose or by modifying <tt>bstree.c</tt> itself
    (I recommend the former.  It is generally a good
    idea to keep the change to the original program
    simple and independent of the analysis).
  </p>
  
  <p class="ja">
    解析プログラムは好きな言語，たとえばPython，で書けばよい(こういうことのためにひとつスクリプト言語を習得するのは良い考えです)が，それには苦労しそうという人のために，<a href=download/lifetime_distribution.py>お助けプログラム</a>を提供しておきます．
  </p>
  <p class="en">
    You can write your own analysis in any language, say Python
    (it is good idea to master a script language for such tasks),
    but if you feel it takes much of your effort, you
    can use <a href=download/lifetime_distribution.py>a helper program</a>
    I wrote.
  </p>
  
  <p class="ja">
    パラメータはグラフを表示するのに無理がない程度の大きさに調節せよ．
    svgファイルに保存してアップロードせよ．
  </p>
  <p class="en">
    Set the parameters to modest values,
    so that the visualization is feasible.
    Create an svg file and upload it.
  </p>
</div>

<h2 class="ja">生きているオブジェクト量の時系列可視化</h2>
<h2 class="en">Visualize the time series of live object size</h2>
<div>
  <p>
    <font color=blue>Q:</font>
  </p>
  <p class="ja">
同様にして，横軸に時刻(メモリ割当量で測る)，縦軸に，
各時点での「生きているオブジェクト量」(bornして，deadになっていないバイト数)
をとり，時系列を可視化せよ．
さっきと同じ<a href=download/lifetime_distribution.py>お助けプログラム</a>は，
少し変更すればこの問題に使えるようになっています．
  </p>
  <p class="en">
    Likewise, show the time series of "the amount of live objects"
    (the total bytes of objects that have been born but are not yet dead),
    having the time (measured by the amount of memory allocation)
    along horizontal axis and the amount of live objects along the
    virtual axis.
    This problem can be done by slightly modifying 
    the same <a href=download/lifetime_distribution.py>helper program.</a>
  </p>

  <p class="ja">
    パラメータは前問と同じにして，できたsvgファイルをアップロードせよ．
  </p>
  <p class="en">
    Use the same parameters as the previous problem
    and upload the generated svg file.
  </p>
</div>

<h2 class="ja">mark-cons比の解析(シミュレーション)</h2>
<h2 class="en">Analyze mark-cons ratio (simulation)</h2>
<div>
  <p class="ja">
    オブジェクトの寿命分布をもとにして，
    ある年齢以下のオブジェクトだけをGC(走査)したと改定した時の，
    mark-cons比を見積もってみよう．
    解析にあたっては，メモリの詳細な使われ方を無視して，
    とにかく個々のオブジェクトが，
    <a href=#visualize_lifetime>
      オブジェクトの寿命を可視化する問題</a>で得た分布(確率)に従い，
    死んでいくものとする．したがって，「あるオブジェクトの寿命がy以下である確率」
    などをこの分布から機械的に求めることができる．
  </p>

  <p class="en">
    Based on the lifetime distribution,
    let's estimate the mark-cons ratio that could result
    if we collect (traverse) only objects younger than
    a certain age.
    For the purpose of estimation, simply 
    assume the lifetime of an object
    is independently drawn from the distribution (probability) obtained in 
    the exercise <a href=#visualize_lifetime>
      "Visualize distribution of object lifetimes."</a>
    With this assumption, you could estimate,
    for example, 
    the probability that an object's lifetime is
    no greater than <tt>y</tt>.
  </p>

  <p>
    <font color=blue>Q:</font>
  </p>
  <p class="ja">
    以下の値を計算せよ.
    計算するプログラムを提出しアップロードすること.
  </p>
  <p class="en">
    Calculate the following values.
    Submit the analysis program and upload it.
  </p>
  
<ul>
  <li class="ja">色々なyに対し，「ある年齢y以下」のオブジェクトだけを走査したときの，mark-cons比．
    横軸にy, 縦軸にmark-cons比をとってグラフを書いて，mark_cons_young.svg というファイル名でアップロードせよ．
  </li>
  <li class="en">mark-cons ratio when only objects younger than y are
    traversed.
    Take y along the horizontal axis and mark-cons ratio along the
    virtual axis and upload the result in mark_cons_young.svg.
  </li>
  
  <li class="ja">色々なヒープサイズで，ヒープ全体から生きているオブジェクトを走査したときのmark-cons比
    (生きているオブジェクトの量は前問の結果から知る)
    横軸にヒープサイズ，縦軸にmark-cons比をとってグラフを書いて，mark_cons_all.svg というファイル名でアップロードせよ．
  </li>
  <li class="en">mark-cons ratio with various heap sizes,
    when all live objects are traversed (the amount of
    live objects are known from the previous question).
    Draw the graph taking heap size along the horizontal axis and
    mark-cons ratio along the vertical axis
    and upload the result with a file named <tt>mark_cons_all.svg</tt>.
  </li>
  
  <li class="ja">このプログラムに対して世代別GCは有効か．考察をmarkdownセルを使って書け</li>
  <li class="en">Is generational GC effective for this program?
    Write your thought in a markdown cell.</li>
</ul>
</div>

<a name=incremental>
<h2 class="ja">Boehm GCのインクリメンタルGCを使ってみる</h2>
<h2 class="en">Try incremental GC of Boehm GC</h2>
<div>
  <p class="ja">
    Boehm GCにはインクリメンタルGCの機能があり，
  </p>
  <p class="en">
    Boehm GC has an incremental GC.
  </p>

  <ul>
    <li class="ja">適当なところ(普通プログラム開始直後)に，
<pre>
GC_enable_incremental();
</pre>
という呼び出しを入れることで，有効にすることができる．</li>
    <li class="en">You can enable it by calling
<pre>
GC_enable_incremental();
</pre>
at any point in the program (normally right after the program starts).
    </li>

    <li class="ja">また，
<pre>
GC_set_time_limit(unsigned long x);
</pre>
という操作で，停止時間を x ミリ秒以内にするよう，
指示することができる．
ただし，アルゴリズムの本質的な問題により，
これが必ず守られるというわけではない．
努力目標という位置づけ．</li>
    <li class="en">Also,
<pre>
GC_set_time_limit(unsigned long x);
</pre>
asks the pause time to be <tt>x</tt> milliseconds.
This is not guaranteed, however, due to
a fundamental limit of the algorithm.
It should be considered as a best-effort target.</li>

    <li class="ja">目標停止時間の現在の値は，
<pre>
unsigned long l = GC_get_time_limit();
(または GC_time_limit)
</pre>
で得られる．
</li>
    <li class="en">The target pause time can be obtained by
<pre>
unsigned long l = GC_get_time_limit();
</pre>
</li>
</ul>

  <p>
    <font color=blue>Q:</font>
  </p>
  
<p class="ja">
前問の<a href=download/bstree.c>2分木探索のプログラム</a>を
変更し，各<t>GC_MALLOC</t>の呼び出しにかかる時間を計測し，
それがある閾値(例: 1ミリ秒)を越えていたらその時間(つまりmutatorの停止時間)
を表示するようにせよ．何回に一度くらいそういうことが起きているかも表示できると
モアベター．
時間の取得はどうやってもよいが，Linux/Macならgettimeofdayを使えば良い．
</p>
  <p class="en">
    Modify the <a href=download/bstree.c>binary search tree program</a>
    of the previous problem, so that you measure the time
    of each call to <tt>GC_MALLOC</tt> and
    prints it (that is, the pause time of the mutator)
    when it is beyond a threshold (e.g., 1 millisecond).
    Even better if you show how frequently it happens.
    There are several ways to obtain time.
    You can use gettimeofday on Linux/Mac.
  </p>

<p class="ja">
  n (= だいたいの木の大きさ)を色々変えて，
  最大の停止時間がどう変わるかを観察してみよ．
</p>
  <p class="en">
    Change n (= approximate size of the tree) and
    how it affects the maximum pause time.
</p>

<p class="ja">
<font color=blue>(余力があれば)</font>
あるGC_MALLOCで，実際にGCがおきたのかを知りたければ以下のようにする．
</p>
<p class="en">
  <font color=blue>(optional)</font>
  You can know whether a particular <tt>GC_MALLOC</tt>
  caused a GC as follows.
</p>
<pre>
GC_word g0 = GC_get_gc_no();
</pre>
<p class="ja">
  という関数呼び出しで
「プログラムが開始されてからその時点までのGC回数」
を得ることができるので，これを用いて調べることができる．
具体的には，<t>GC_MALLOC</t>呼び出しの前後でこの値を
見て，変化していればその<t>GC_MALLOC</t>の中で，
  GCが行われたことになる．
</p>
<p class="en">
  tells you "the number of times GCs have happened";
  you can therefore know that
  a <tt>GC_MALLOC</tt> triggered a GC when
  this value is changed between before and after
  <tt>GC_MALLOC</tt>.
</p>

<p class="ja">
<font color=blue>(余力があれば)</font>
GCの停止時間がプログラムの対話性に与える影響を，
もう少し実感したい場合は，プログラムを変更して，
定期的に，例えばノードを割り当てる直前，
で「ある目標時間(例: 30ミリ秒)に一回，画面に一文字表示する」
という風にプログラムを変更してみよ．普通は改行をしないと画面に
反映されないので注意．fflush(stdout)を呼ぶと反映してくれる．
</p>

<p class="en">
  <font color=blue>(optional)</font>
  If you want to feel how pause time affects
  the interactivity of a program, change the
  program so that it tries to "print a character
  at a specified target interval
  (e.g., every 30 milliseconds)
  at some point in the program, 
  say immediately before allocating a node.
  "
  Remember that a character won't appear,
  by default, on the screen until you print a new line.
  <tt>fflush(stdout)</tt> will immediately
  update the screen.
</p>

<pre>
printf("."); fflush(stdout);
</pre>

<p class="ja">
<t>GC_MALLOC</t>に長時間かかってしまうと，
それが達成できなくなるということ．
</p>
<p class="en">
  That is, if <tt>GC_MALLOC</tt> takes long,
  the program will miss the update.
</p>
</div>

<!--
<a name=incremental>
<h2>OCamlのGCの停止時間を測ってみる</h2>
<div>
アルゴリズムの本質的な問題もあり，Boehm GCの停止時間はそれほどしっかりしているとは言えない．
今度は，<a href=download/bstree.ml>2分木探索プログラムのOCaml版</a>
をダウンロードして，同じようにメモリ割り当て1回にかかる最大の時間(停止時間)を
測ってみよう．上記プログラムをダウンロードし，まずは以下で実行できるか確認してみよ
(unix.cmaは，gettimeofday関数を使うために必要)．
<pre>
$ ocaml unix.cma bstree.ml 
78 nodes in the tree
</pre>
うまくいったらプログラムを確認し，木のノードを作っているところ
を見つけ，その部分でにかかる時間を計測してみよ．
Boehm GCのときと同様，それが適当な閾値(例えば 1ミリ秒)
を越えていたら表示するようにしてみよ．
<br />
<font color=blue>(余力があれば)</font>
また，OCamlの
<a href=http://caml.inria.fr/pub/docs/manual-ocaml/libref/Gc.html>Gcモジュール
</a>を用いると，GCが起きた回数を知ることができる．
(<t>Gc.quick_stat</t>関数およびその返り値の中の，
<t>minor_collections, major_collections</t>
というフィールド．それを用いて，GCの回数もあわせて表示してみよ．
</div>
-->

</body>
</html>
